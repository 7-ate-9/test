---
layout: default
title: eBird Voice Input
---

<div id="root"></div>

<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<script type="text/babel">
const { useState } = React;

const Button = ({ children, onClick, disabled, variant = 'default', className = '' }) => {
  const baseStyles = 'px-4 py-2 rounded-lg font-medium transition-colors flex items-center justify-center';
  const variants = {
    default: 'bg-blue-600 text-white hover:bg-blue-700 disabled:bg-blue-300 disabled:cursor-not-allowed',
    outline: 'border-2 border-gray-900 bg-white text-gray-900 hover:bg-gray-100 disabled:border-gray-400 disabled:text-gray-400 disabled:cursor-not-allowed'
  };
  return (
    <button 
      onClick={onClick} 
      disabled={disabled}
      className={`${baseStyles} ${variants[variant]} ${className}`}
    >
      {children}
    </button>
  );
};

const Card = ({ children, className = '' }) => (
  <div className={`bg-white rounded-lg shadow-lg ${className}`}>{children}</div>
);

const CardHeader = ({ children }) => (
  <div className="px-6 py-4 border-b">{children}</div>
);

const CardTitle = ({ children }) => (
  <h2 className="text-2xl font-bold">{children}</h2>
);

const CardContent = ({ children, className = '' }) => (
  <div className={`px-6 py-4 ${className}`}>{children}</div>
);

const Alert = ({ children, variant = 'default' }) => {
  const variants = {
    default: 'bg-blue-50 border-blue-200',
    destructive: 'bg-red-50 border-red-200'
  };
  return (
    <div className={`border-2 rounded-lg p-4 ${variants[variant]}`}>
      {children}
    </div>
  );
};

const AlertDescription = ({ children, className = '' }) => (
  <div className={className}>{children}</div>
);

const Mic = ({ className }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
  </svg>
);

const MicOff = ({ className }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
  </svg>
);

const Download = ({ className }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
  </svg>
);

const Trash = ({ className }) => (
  <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
  </svg>
);

const EBirdVoiceInput = () => {
  const [isListening, setIsListening] = useState(false);
  const [birds, setBirds] = useState([]);
  const [transcript, setTranscript] = useState('');
  const [error, setError] = useState('');
  const [debugInfo, setDebugInfo] = useState('');
  const [coords, setCoords] = useState(null);
  const [recognitionInstance, setRecognitionInstance] = useState(null);
  const listeningRef = React.useRef(false);
  const lastEntryTimeRef = React.useRef(null);

  const wordsToNumbers = (text) => {
    const ones = {
      'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
      'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10,
      'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15,
      'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19
    };
    
    const tens = {
      'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,
      'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90
    };
    
    const scales = {
      'hundred': 100,
      'thousand': 1000,
      'million': 1000000
    };
    
    let result = text.toLowerCase();
    
    // Handle compound numbers like "twenty-three" or "twenty three"
    for (const [tenWord, tenVal] of Object.entries(tens)) {
      for (const [oneWord, oneVal] of Object.entries(ones)) {
        if (oneVal < 10) {
          result = result.replace(new RegExp(tenWord + '[-\\s]' + oneWord, 'g'), (tenVal + oneVal).toString());
        }
      }
    }
    
    // Handle "X hundred Y" or "X thousand Y" patterns
    // e.g., "two thousand three hundred" or "five hundred fifty"
    const complexPattern = /(\w+)\s+(hundred|thousand)\s+(?:and\s+)?(\w+)?/g;
    result = result.replace(complexPattern, (match, num1, scale, num2) => {
      const n1 = ones[num1] || tens[num1] || parseInt(num1) || 1;
      const scaleVal = scales[scale];
      const n2 = ones[num2] || tens[num2] || parseInt(num2) || 0;
      return (n1 * scaleVal + n2).toString();
    });
    
    // Handle simple scales "X hundred" or "X thousand"
    for (const [scaleWord, scaleVal] of Object.entries(scales)) {
      for (const [numWord, numVal] of Object.entries({...ones, ...tens})) {
        result = result.replace(new RegExp('\\b' + numWord + '\\s+' + scaleWord + '\\b', 'g'), 
                                (numVal * scaleVal).toString());
      }
    }
    
    // Handle standalone scale words (assume "a hundred" = 100)
    result = result.replace(/\ba\s+hundred\b/g, '100');
    result = result.replace(/\ba\s+thousand\b/g, '1000');
    
    // Replace simple number words
    for (const [word, num] of Object.entries({...ones, ...tens})) {
      result = result.replace(new RegExp('\\b' + word + '\\b', 'g'), num.toString());
    }
    
    return result;
  };

  const processCommand = (command) => {
    const converted = wordsToNumbers(command);
    const lower = converted.toLowerCase();
    
    if (lower.includes('done') || lower.includes('stop') || lower.includes('finish')) {
      stopListening();
      return true;
    }
    
    // Check for modification commands (add/subtract/plus/minus)
    const modifyMatch = lower.match(/(add|plus|subtract|minus|remove)\s+(\d+)\s+(.+)/);
    if (modifyMatch) {
      const [_, action, countStr, species] = modifyMatch;
      const count = parseInt(countStr);
      const cleanSpecies = cleanSpeciesName(species.trim());
      
      if (action === 'subtract' || action === 'minus' || action === 'remove') {
        modifyBirdCount(cleanSpecies, -count);
      } else {
        modifyBirdCount(cleanSpecies, count);
      }
      return true;
    }
    
    // Pattern 1: "5 American Robin" or "5 American Robins"
    let match = lower.match(/^(\d+)\s+(.+)/);
    if (match) {
      const [_, count, species] = match;
      addBird(parseInt(count), cleanSpeciesName(species.trim()));
      return true;
    }
    
    // Pattern 2: "American Robin, 5" or "American Robin 5"
    match = lower.match(/^([a-z\s'-]+?)[,\s]+(\d+)$/);
    if (match) {
      const [_, species, count] = match;
      addBird(parseInt(count), cleanSpeciesName(species.trim()));
      return true;
    }
    
    // Pattern 3: "I saw/had/spotted 3 Blue Jays"
    match = lower.match(/(?:i\s+)?(?:saw|had|spotted|observed|heard)\s+(\d+)\s+(.+)/);
    if (match) {
      const [_, count, species] = match;
      addBird(parseInt(count), cleanSpeciesName(species.trim()));
      return true;
    }
    
    // Pattern 4: Just species name (assume count of 1)
    // But exclude common filler words
    const fillerWords = ['the', 'a', 'an', 'some', 'add', 'subtract', 'i', 'saw', 'had', 'spotted'];
    const words = lower.trim().split(/\s+/);
    const hasOnlyFillers = words.every(w => fillerWords.includes(w) || /^\d+$/.test(w));
    
    if (lower.length > 2 && !lower.match(/^\d/) && !hasOnlyFillers) {
      const cleaned = cleanSpeciesName(lower.trim());
      if (cleaned.length > 0) {
        addBird(1, cleaned);
        return true;
      }
    }
    
    return false;
  };
  
  const cleanSpeciesName = (name) => {
    // Remove common filler words from the beginning/end
    let cleaned = name.toLowerCase();
    cleaned = cleaned.replace(/^(i\s+)?(saw|had|spotted|observed|heard|the|a|an|some)\s+/gi, '');
    cleaned = cleaned.replace(/\s+(bird|birds)$/gi, '');
    
    // Capitalize each word (eBird format)
    cleaned = cleaned.split(' ').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
    
    return cleaned.trim();
  };
  
  const addBird = (count, species) => {
    // Use the last entry time if within 3 minutes, otherwise use current time
    const now = new Date();
    let entryTime = now;
    
    if (lastEntryTimeRef.current) {
      const diffMinutes = (now - lastEntryTimeRef.current) / (1000 * 60);
      if (diffMinutes <= 3) {
        entryTime = lastEntryTimeRef.current; // Use same time for grouping
      } else {
        lastEntryTimeRef.current = now;
      }
    } else {
      lastEntryTimeRef.current = now;
    }
    
    const newBird = {
      species: species,
      count: count,
      date: entryTime.toISOString().split('T')[0],
      time: entryTime.toTimeString().split(' ')[0],
      lat: coords?.latitude ?? null,
      lng: coords?.longitude ?? null
    };
    setBirds(prev => [...prev, newBird]);
    setDebugInfo(prev => prev + `\nAdded: ${count} ${species}, coords: ${newBird.lat}, ${newBird.lng}`);
  };
  
  const modifyBirdCount = (species, delta) => {
    setDebugInfo(prev => prev + `\nTrying to modify: ${species}`);
    setBirds(prev => {
      // Try to find existing entry with fuzzy matching
      let existing = null;
      let existingIndex = -1;
      
      for (let i = 0; i < prev.length; i++) {
        setDebugInfo(p => p + `\nComparing "${prev[i].species}" with "${species}": ${speciesMatch(prev[i].species, species)}`);
        if (speciesMatch(prev[i].species, species)) {
          existing = prev[i];
          existingIndex = i;
          break;
        }
      }
      
      if (existing) {
        setDebugInfo(p => p + `\nFound match at index ${existingIndex}, current count: ${existing.count}, delta: ${delta}`);
        // Modify existing entry
        const newCount = Math.max(0, existing.count + delta);
        if (newCount === 0) {
          // Remove entry if count becomes 0
          return prev.filter((_, i) => i !== existingIndex);
        }
        return prev.map((b, i) => 
          i === existingIndex ? { ...b, count: newCount } : b
        );
      } else {
        setDebugInfo(p => p + `\nNo match found for "${species}"`);
        if (delta > 0) {
          // Add new entry if it doesn't exist and delta is positive
          const now = new Date();
          return [...prev, {
            species: species,
            count: delta,
            date: now.toISOString().split('T')[0],
            time: now.toTimeString().split(' ')[0],
            lat: coords?.latitude ?? null,
            lng: coords?.longitude ?? null
          }];
        }
      }
      return prev;
    });
  };
  
  // Fuzzy matching for species names (handles plurals, minor typos)
  const speciesMatch = (name1, name2) => {
    const normalize = (name) => {
      return name.toLowerCase()
        .replace(/geese$/i, 'goose') // Handle geese -> goose specifically
        .replace(/ies$/i, 'y') // berries -> berry
        .replace(/ves$/i, 'f') // wolves -> wolf
        .replace(/s$/, '') // Remove trailing 's' for most plurals
        .replace(/[^a-z\s]/g, '') // Remove non-letters except spaces
        .trim();
    };
    
    const n1 = normalize(name1);
    const n2 = normalize(name2);
    
    // Exact match after normalization
    if (n1 === n2) return true;
    
    // Also check if the words are similar enough
    const words1 = n1.split(/\s+/);
    const words2 = n2.split(/\s+/);
    
    // If same number of words, check word-by-word similarity
    if (words1.length === words2.length) {
      let matches = 0;
      for (let i = 0; i < words1.length; i++) {
        if (words1[i] === words2[i]) {
          matches++;
        } else if (words1[i].includes(words2[i]) || words2[i].includes(words1[i])) {
          if (Math.min(words1[i].length, words2[i].length) / Math.max(words1[i].length, words2[i].length) > 0.7) {
            matches++;
          }
        }
      }
      return matches === words1.length;
    }
    
    return false;
  };

  const startListening = () => {
    setError('');
    setTranscript('');
    setDebugInfo('Initializing speech recognition...');

    if (navigator.geolocation && !coords) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const newCoords = {
            latitude: position.coords.latitude,
            longitude: position.coords.longitude
          };
          setCoords(newCoords);
          setDebugInfo(prev => prev + `\nGPS: ${newCoords.latitude}, ${newCoords.longitude}`);
        },
        (error) => {
          console.log('Geolocation error:', error);
          setDebugInfo(prev => prev + `\nGPS error: ${error.message}`);
        }
      );
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      setError('Speech recognition is not supported in your browser.');
      setDebugInfo('No SpeechRecognition constructor found');
      return;
    }

    try {
      const recognition = new SpeechRecognition();
      setDebugInfo('Recognition instance created');
      
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';
      
      recognition.onstart = () => {
        setIsListening(true);
        listeningRef.current = true;
        setError('');
        setDebugInfo('Recognition started successfully');
      };

      recognition.onresult = (event) => {
        const lastResult = event.results[event.results.length - 1];
        const command = lastResult[0].transcript;
        setTranscript(command);
        setDebugInfo(prev => prev + `\nReceived: ${command}`);
        
        if (!processCommand(command)) {
          setError('Not recognized. Try: "3 American Robin" or say "Done" to finish');
        } else {
          setError(''); // Clear error on success
        }
      };

      recognition.onerror = (event) => {
        setDebugInfo(prev => prev + `\nError: ${event.error}`);
        
        switch (event.error) {
          case 'no-speech':
            // Don't stop on no-speech in continuous mode
            break;
          case 'aborted':
            // Normal stop
            break;
          case 'audio-capture':
            setError('No microphone was found. Please check your microphone settings.');
            setIsListening(false);
            listeningRef.current = false;
            break;
          case 'network':
            setError('Network error occurred. Please check your connection.');
            setIsListening(false);
            listeningRef.current = false;
            break;
          case 'not-allowed':
            setError('Microphone access was denied. Please check your permissions.');
            setIsListening(false);
            listeningRef.current = false;
            break;
          case 'service-not-allowed':
            setError('Speech service is not allowed. Please try again.');
            setIsListening(false);
            listeningRef.current = false;
            break;
          default:
            setError(`Recognition error: ${event.error}`);
            setIsListening(false);
            listeningRef.current = false;
        }
      };

      recognition.onend = () => {
        setDebugInfo(prev => prev + '\nRecognition ended');
        // Check the ref instead of state to avoid stale closure
        if (listeningRef.current) {
          setDebugInfo(prev => prev + '\nRestarting...');
          setTimeout(() => {
            try {
              recognition.start();
            } catch (e) {
              console.log('Failed to restart:', e);
              setDebugInfo(prev => prev + `\nRestart failed: ${e.message}`);
              setIsListening(false);
              listeningRef.current = false;
            }
          }, 100);
        }
      };

      setDebugInfo(prev => prev + '\nStarting recognition...');
      recognition.start();
      setRecognitionInstance(recognition);
      
    } catch (err) {
      console.error('Recognition error:', err);
      setError(`Failed to start speech recognition: ${err.message}`);
      setDebugInfo(`Error detail: ${err.toString()}`);
      setIsListening(false);
      listeningRef.current = false;
    }
  };
  
  const stopListening = () => {
    listeningRef.current = false;
    setIsListening(false);
    if (recognitionInstance) {
      recognitionInstance.stop();
      setRecognitionInstance(null);
    }
  };

  const generateCSV = () => {
    if (birds.length === 0) return;
    
    const headers = ['Common Name', 'Count', 'Latitude', 'Longitude', 'Date', 'Time', 'Protocol'];
    const rows = birds.map(bird => [
      `"${bird.species}"`,
      bird.count,
      bird.lat !== null ? bird.lat.toFixed(6) : '',
      bird.lng !== null ? bird.lng.toFixed(6) : '',
      bird.date,
      bird.time,
      'Incidental'
    ]);
    
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ebird-checklist-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  return (
    <Card className="w-full max-w-2xl mx-auto my-8">
      <CardHeader>
        <CardTitle>eBird Voice Input</CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="bg-blue-50 border-2 border-blue-900 rounded-lg p-4">
          <h3 className="font-bold text-lg mb-2 text-gray-900">üìã Voice Commands:</h3>
          <div className="text-base space-y-1 text-gray-900">
            <div><strong>Add birds:</strong> "3 American Robin" or "two thousand Mallard"</div>
            <div><strong>Modify count:</strong> "Add 50 Snow Goose" or "Subtract 10 Mallard"</div>
            <div><strong>Natural speech:</strong> "I saw five hundred Cardinals"</div>
            <div><strong>Finish:</strong> "Done" or "Stop"</div>
          </div>
          {!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window) && (
            <div className="mt-2 text-sm text-red-600 font-medium">
              ‚ö†Ô∏è Speech recognition not supported. Please use Chrome, Edge, or Samsung Internet.
            </div>
          )}
        </div>

        <div className="flex flex-col gap-4">
          <Button 
            onClick={isListening ? stopListening : startListening}
            className="h-20 text-xl"
          >
            {isListening ? <MicOff className="mr-3 h-8 w-8" /> : <Mic className="mr-3 h-8 w-8" />}
            {isListening ? 'Stop Listening' : 'Start Listening'}
          </Button>
          <div className="flex gap-4">
            <Button
              onClick={() => setBirds([])}
              variant="outline"
              className="flex-1 h-16 text-lg"
            >
              <Trash className="mr-2 h-6 w-6" />
              Clear
            </Button>
            <Button
              onClick={generateCSV}
              disabled={birds.length === 0}
              variant="outline"
              className="flex-1 h-16 text-lg"
            >
              <Download className="mr-2 h-6 w-6" />
              Download
            </Button>
          </div>
        </div>

        {error && (
          <Alert variant="destructive">
            <AlertDescription className="text-gray-900 font-medium">{error}</AlertDescription>
          </Alert>
        )}

        {isListening && (
          <Alert>
            <AlertDescription className="text-lg text-gray-900 font-medium">
              üé§ Listening... Say bird name and count (e.g., "3 American Robin"). Say "Done" to finish.
            </AlertDescription>
          </Alert>
        )}

        {transcript && (
          <div className="text-lg text-gray-900 font-medium">
            Last heard: {transcript}
          </div>
        )}

        <div className="border-2 border-gray-900 rounded-lg p-4 bg-white">
          <h3 className="font-bold text-xl mb-3 text-gray-900">Recorded Sightings ({birds.length}):</h3>
          {birds.length === 0 ? (
            <p className="text-lg text-gray-700">No birds recorded yet.</p>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full text-left">
                <thead>
                  <tr className="border-b-2 border-gray-900">
                    <th className="pb-2 pr-4 text-gray-900">Count</th>
                    <th className="pb-2 pr-4 text-gray-900">Species</th>
                    <th className="pb-2 text-gray-900">Time</th>
                  </tr>
                </thead>
                <tbody>
                  {birds.map((bird, index) => (
                    <tr key={index} className="border-b border-gray-300">
                      <td className="py-2 pr-4 text-lg font-bold text-gray-900">{bird.count}</td>
                      <td className="py-2 pr-4 text-base text-gray-900">{bird.species}</td>
                      <td className="py-2 text-sm text-gray-700">{bird.time}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>

        {coords && (
          <div className="text-base text-gray-900 font-medium">
            üìç Location: {coords.latitude.toFixed(4)}, {coords.longitude.toFixed(4)}
          </div>
        )}

        <div className="text-sm text-gray-700 whitespace-pre-wrap">
          {debugInfo}
        </div>
      </CardContent>
    </Card>
  );
};

ReactDOM.render(<EBirdVoiceInput />, document.getElementById('root'));
</script>
